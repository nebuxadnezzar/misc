#!/usr/bin/env /usr/bin/python3
import sys

"""
This code works for direct graphs but not for the cases where you loop back to
the same node such as this case:
(0,0) -> (1,0) -> (2,0) -> (2,1) -> (2,2) -> (1,2) -> (2,2) -> (2,3) -> (2,4).
where (2,2) visited twice. I couldn't figure yet how to do that whitout getting
into eldless recursion.
"""

'''
Use DFS to find all possible direct paths (not containing loops) through the matrix
'''
def go(rect, idx, visited, counted, path, paths):
    if idx in visited \
        or idx >= len(rect) \
        or idx < 0:
        return

    s = rect[idx]
    if s == "#": return
    if s == '*':
        if not idx in counted:
            p = f"{path};{s}{coord(idx)}".lstrip(';')
            paths.append(p)
            counted.add(idx)
    visited.add(idx)

    for dir in (R, D, L, U):
        if dir == R and coord(idx)[1]+1 > F - 1:
            continue
        go(rect, idx + dir, visited, counted,f"{path};{s}{coord(idx)}", paths)

#==============================================================================
'''
Build map based direct acyclic graph
'''
def build_graph(graph, path):
    l = len(path)
    for i in range(l):
        if i + 1 < l:
            add_to_graph(graph, path[i], path[i+1])
    if l > 1:
        add_to_graph(graph, path[l-1], path[l-2])
    else:
        add_to_graph(graph, path[l-1], None)
#==============================================================================
def add_to_graph(m, key, v):
    if key in m:
        if v != None:
            m[key].add(v)
    elif v == None:
        m[key] = set([])
    else:
        m[key] = set([v])
#==============================================================================
def coord(idx):
    return (idx // F, idx % F)
#==============================================================================
def ischeckpoint(key):
    return key.find('*') == 0
#==============================================================================
def isvisited(m, key):
    return key in m and m[key] > 1
#==============================================================================
'''
Iterate graph map connecting K amout of check points
'''
def calculate_helper(m, K, cnt, key, path, length, visited, lenlist):

    if key in visited:
        return

    if ischeckpoint(key):
        visited.add(key)
        cnt += 1
        if cnt >= K:
            print(f'=> {path} {key} {length}')
            lenlist.append(length)

    for kk in m[key]:
        calculate_helper(m, K, cnt, kk, f'{path} {key}', length + 1, visited, lenlist)

#==============================================================================
def calculate(m, K):
    lengthlist = []
    for key in m.keys():
        if ischeckpoint(key):
            calculate_helper(m, K, 0, key, "", 0, set([]), lengthlist)
    # print(f"\n\tLENGTH RETURNED: {lengthlist}\n")
    l = len(lengthlist)
    return sum(lengthlist) / l if l > 0 else 0

#==============================================================================
def expected_length(paths, K):
    graph = {}
    for p in paths:
        build_graph(graph, p.split(';'))
    return calculate(graph, K)
#==============================================================================

def main(args):
    global L, R, D, U, F
    L = -1
    R = 1


    for i in range(len(cases)):
        rect, f, start, K = cases[i]
        paths = []
        print(f'RUNNING for field len {f} K {K} {rect} {len(rect)}')
        F, D, U = f, f, -f
        go(rect, start, set([]), set([]), "", paths)
        print(f'RETURNED: {expected_length(paths, K)}')
        #print(f"\nMAP\n{m}")
        paths.clear()

cases =\
[
    (
    "*#..#" +\
    ".#*#."+\
    "*...*"
    , 5, 0, 2),
    (
    "#.#**"+\
    "....#"+\
    "#*#**"+\
    "**#*#"+\
    "#..##"+\
    "*#..#"+\
    ".#.#."+\
    "....*"
    , 5, 3, 3),
    (
    "###################"+\
    "#*###############*#"+\
    "#.....#######.....#"+\
    "#*###*.#.*.#.*###*#"+\
    "#*####*.*#*.*####*#"+\
    "#*#####*###*#####*#"+\
    "###################"
    , 19, 20, 9),
    (
    "**##*.**#..#.*...*#...*#..#.##..#..#.#*...#.##*##."+\
    ".#..###..#..#.#.##..#.#.*#.*..#..#.#*..##.#*...*.."+\
    "..#.....###.#*.##..#.#.#*..#.#..#....#..#...#*####"+\
    ".#.##*#.*#..#*#*.#.#...*.#.*#.#.##.#*.##.#.#..*..."+\
    "..*.*#*.###.#..#.#..##.##.*#..#.....#.....#..#.#.#"+\
    ".#.##.#..##..*#..#.#...#*##*#*..#.#.#.#.##.##.#.#*"+\
    "..##....#..#.#*#...*.##...#.#.####...#.#*.....#..."+\
    ".#.*#.##.*#*.#*.#.#.#..#.#..#.#*#.###..##.##.#.##*"+\
    ".*.#*..*.#.#...#.*##.#.**.#.*...**..*#..#.#.#*.#.."+\
    ".#*.#*##....##.#.#*..*.###.#.##.##.#.#.#....#.#*.#"+\
    "*.#..#*#.#*#*....#.#.#..*#**...##.#.#.**#*##.*.#.."+\
    ".#*.##..##..##.#.#..#.#.###.###...#...#*#..##*#.#."+\
    "#..#*.#..*.###..#.#...#.###.#.#*#.#.#**##.#...*.#*"+\
    "..#..#.#.##.#..#.**.##*#.#**.**..#.#..#...#.##*#.."+\
    ".#*#.#.*..#.*#...#.#...#...#.##.#..*#*.##*....###."+\
    ".*.#.#.#.#*#..*##.**.##*##..#.*#.#*###..*.#.##.#.."+\
    ".#......#...#.#.*#.#.#..#..#.#*#....#*.#*#.*#..*.#"+\
    "#..####..#*#...#*.#..#.###...#.#.#.###*#..##*##.#."+\
    ".#.*..#.#...#.#..#.##...#..#.#.#.#.###..##..*.*.*."+\
    ".#.#.#.#..##.*..#.*.#.##.#..##*...#.#..#.#.##.#.##"+\
    ".#..#*.#.#..#.##..##..#.*..#.*#.#...##....#...###."+\
    ".#.#.#.#*.#.#..#.#..#..#.#.*#...#.##...#.##.##.*.."+\
    ".#...#.#.##.#.#..*#.*#..###..#.#.#*###.##...#*.##."+\
    ".#.##.*.......*.#.*#.#.#*###..*...*..#.*.##.#.#..#"+\
    "...###*####*#.#..##*...#..#..##.#.#.#..##*#*.*.*#."+\
    "#.#.#....*#..#.#.#.#.##..#*.#...#..#.#*#...#.##.*."+\
    "..*.#*##.#.#*#.###...#..##.#.#.#*###*#.*#.#.*###.#"+\
    "##*##..##...#.....##.#.#.**#..#*.....##.#..#*.#.*."+\
    ".....#.*.##..##.##*.*#...#.#.#.##.#*#.**..#..#.#.#"+\
    "##.#.#*##.#.#.*.*.#.#*#.#.#....*...#*##*##.#....#."+\
    "*.**#**....*..##.#*.*.**..##.###.##.....##...##.**"+\
    "#.####.##*#*##..#.*#*#.##*...#.##..#.##....#*..##."+\
    "....#...##.#...#*.#..##.##.#*..*.#....##.#.*##...#"+\
    "#.#..*##*..#.#..#..#..#*....#.##..##.#*##.##.*##.."+\
    "..#.#*.*.##.#.#*#.#*##.###.##...#............#*.#."+\
    "#.#.##.#....*....*..##..*#.#.#.###.#.#.#.###..#..#"+\
    ".#**..#*#.#*#*#.#.#...*##....##.#*..#..#*..*#..#.."+\
    "...#*#.....#..#.#..#*#.*##.#..#.#.##..#.*#*#.#...#"+\
    ".#*.###.#.#.#.#.*#*##.##..#.#*..#...#.#.#..#*.*#.."+\
    "#*.#.#.#..#..#..#....*#.*##..##.#.#..#...##.#.#..#"+\
    "*.#..#..#...#..##.#*#..#.#*#.#.#.###..#.#*...#.#.."+\
    "#...#.#...#.#.#..#.*.#*.....**.*..#*##.#*.##....##"+\
    "#*#....#*#..#.*.###*#..#*##.##.#.#...#.*.##.##.##."+\
    "..##*##*..#*#.#..#*.*##*.##.#...#.#.#.#.#..*#.##.."+\
    "#...#*##.#*#**.##.*#.*.##..*.#*#**....#**##...*.*#"+\
    "*#.##......*#.##.#.#.##**.#.#.#.#.#.##..#...#*#*#*"+\
    "*....##.#.#..#.....#..##.#....*....#.#.##.#.#.##**"+\
    "#.##*#...#..#.#.##..#..##.##.##.##........##.#*#.#"+\
    "..#...#.#*#*..*#..*#.*#.#......##.#.#.#*#..#..****"+\
    ".###.#..#...#.#..#..#.#...#.#.#...**.#..*#*.*##*#."
    , 50, 0, 150)
]
if __name__ == '__main__':
    print(f'RECURSION LIMIT: {sys.getrecursionlimit()}')
    sys.setrecursionlimit(sys.getrecursionlimit() * 10)
    sys.exit(main(sys.argv))
